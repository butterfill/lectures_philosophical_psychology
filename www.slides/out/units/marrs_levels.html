
<!-- - scripts.add(["/vendor/deck.js/deck.core.js"])--><!-- - scripts.add(["/vendor/deck.js/deck.menu.js"])--><!-- - scripts.add(["/vendor/deck.js/deck.hash.js"])--><!-- - scripts.add(["/vendor/deck.js/deck.notes.js"])--><html><head><!-- (c) copyright 2013 Stephen A. Butterfill--><meta charset="utf-8"/><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/><title>Marr’s Threefold Distinction | Philosophical Psychology</title><meta name="description" content="Marr helpfully distinguishes computational description (What is the thing for and how does it achieve this?)
from representations and algorithms (How are the inputs and outputs represented, and how is the transformation accomplished?)
and from the hardware implementation (How are the  representations and algorithms physically realised?)"/><meta name="keywords" content="philosophy, psychology, action, joint action, metarepresentation, perception"/><meta name="author" content=""/><meta name="generator" content="DocPad v6.78.4" /><meta name="viewport" content="width=device-width"/><!-- - lato font--><link href="https://fonts.googleapis.com/css?family=Lato:300,400,900,400italic" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=The+Girl+Next+Door" rel="stylesheet" type="text/css"/><!--if lt IE 9script(async src="http://html5shim.googlecode.com/svn/trunk/html5.js")
--><link  rel="stylesheet" href="/vendor/boilerplate.min.css" /><link  rel="stylesheet" href="/vendor/normalize.min.css" /><link  rel="stylesheet" href="/vendor/deck.js/deck.all.min.css" /><link  rel="stylesheet" href="/vendor/960_12_col_custom.min.css" /><link  rel="stylesheet" href="/styles/steve_deck_style.css" /><link  rel="stylesheet" href="/vendor/questionmark.js/question.mark.css" /></head><body><script defer="defer"  src="/vendor/jquery.min.js"></script><script defer="defer"  src="/vendor/jquery-svgfix.js"></script><script defer="defer"  src="/vendor/jquery.crSplineBkg.js"></script><script defer="defer"  src="/vendor/velocity.min.js"></script><script defer="defer"  src="/vendor/marked.min.js"></script><script defer="defer"  src="/vendor/modernizr.custom.01932.js"></script><script defer="defer"  src="/vendor/deck.js/deck.velocity.js"></script><script defer="defer"  src="/vendor/deck.js/deck.all.min.js"></script><script defer="defer"  src="/vendor/jquery.jsPlumb-1.3.16-all-min.js"></script><script defer="defer"  src="/scripts/script.js"></script><script defer="defer"  src="/vendor/questionmark.js/question.mark.min.js"></script><div id="helpUnderlay" class="help-underlay"><div id="helpModal" class="help-modal"><h1>Keyboard Shortcuts<kbd class="help-key"><span>?</span></kbd></h1><div id="helpClose" class="help-close">×</div><!-- .help-close--><div id="helpModalContent" class="help-modal-content"><div id="helpListWrap" class="help-list-wrap"><ul class="help-list"><li class="help-key-unit"><kbd class="help-key"><span>→</span></kbd><span class="help-key-def">Next step</span></li><li class="help-key-unit"><kbd class="help-key"><span>←</span></kbd><span class="help-key-def">Previous step</span></li><li class="help-key-unit"><kbd class="help-key"><span>↓</span></kbd><span class="help-key-def">Skip this slide</span></li><li class="help-key-unit"><kbd class="help-key"><span>↑</span></kbd><span class="help-key-def">Previous slide</span></li><li class="help-key-unit"><kbd class="help-key"><span>m</span></kbd><span class="help-key-def">Show slide thumbnails</span></li><li class="help-key-unit"><kbd class="help-key"><span>n</span></kbd><span class="help-key-def">Show notes</span></li><li class="help-key-unit"><kbd class="help-key"><span>h</span></kbd><span class="help-key-def">Show handout latex source</span></li><li class="help-key-unit"><kbd class="help-key"><span>N</span></kbd><span class="help-key-def">Show talk notes latex source</span></li></ul><!-- .help-list--></div><!-- .help-list-wrap--></div><!-- .help-modal-content--></div><!-- .help-modal--></div><!-- .help-underlay-->
<div class="deck-notes"><div class="deck-notes-container"></div></div><div class="deck-handout"><div class="deck-handout-container"></div></div><div class="deck-container"><section id="instructions" class="slide"><div class="words"><div class="container_12"><div class="grid_12"><div class="middle"><p class="center">Click here and press the right key for the next slide (or swipe left)</p></div></div></div></div></section><section class="slide"><!-- .notes You won't believe how many people emailed me to say the slides don't work.--><div class="words"><div class="container_12"><div class="grid_12"><p>also ...</p><p>Press the left key to go backwards (or swipe right)</p><p>Press n to toggle whether notes are shown (or add '?notes' to the url before the #)</p><p>Press m or double tap to slide thumbnails (menu)</p><p>Press ? at any time to show the keyboard shortcuts</p></div></div></div></section><section id="marrs_levels" class="slide"><div class="spacer">&nbsp;</div><div style="" class="title-block"><div class="title-container"><h2 class="title1">Marr’s Threefold Distinction</h2></div></div></section>
<!-- param @cls and param @options should be objects-->



<section style="" class="slide"><div style="" class="container_12"><div class="grid_12 "><div class="words"><div class="middle"><div class="handout">\citet[p.~22ff]{Marr:1982kx} distinguishes:</div><div class="handout">\begin{itemize}</div><div class="handout">\item computational description---What is the thing for and how does it achieve this?</div><div class="handout">\item representations and algorithms---How are the inputs and outputs represented, and how is the transformation accomplished?</div><div class="handout">\item hardware implementation---How are the representations and algorithms physically realised?</div><div class="handout">\end{itemize}</div><div class="notes">One possibility is to appeal to David Marr’s famous three-fold distinction
bweteen levels of description of a system: the computational theory, the 
representations and algorithm, and the hardware implementation.</div><div class="notes">This is easy to understand in simple cases.
To illustrate, consider a GPS locator.
It receives information from four satellites and tells you where on Earth the device is.</div><div class="notes">There are three ways in which we can characterise this device.</div><div class="slide"><div class="computational"><p>1. computational description</p><div class="notes">First, we can explain how in theory it is possible to infer the 
device’s location from it receives from satellites.
This involves a bit of maths: given time signals from four different satellites,
you can work out what time it is and how far you are away from each
of the satellites.
Then, if you know where the satellites are and what shape the Earth is,
you can work out where on Earth you are.</div><div class="slide"><p class="indent">-- What is the thing for and how does it achieve this?</p></div><div class="notes">The computational description tells us what the GPS locator does and 
what it is for.
It also establishes the theoretical possibility of a GPS locator.</div><div class="notes">But merely having the computational description does not enable you to build 
a GPS locator, nor to understand how a particular GPS locator works.
For that you also need to identify representations and alogrithms ...</div></div></div><div class="slide"><p class="em-above">2. representations and algorithms</p><div class="notes">At the level of representations and algorthms we specify 
how the GPS receiver represents the information it receives from the satellites
(for example, it might in principle be a number, a vector or a time).
We also specify the algorithm the device uses to compute the time and its location.
The algorithm will be different from the computational theory: it is a procedure
for discovering time and location.
The algorithm may involve all kinds of shortcuts and approximations.
And, unlike the computational theory, constraints on time, memory and other
limited resources will be evident.</div><div class="slide"><div class="notes">So an account of the representations and algorithms tells us ...</div><p class="notes show indent">-- How are the inputs and outputs represented, and how is the transformation accomplished?</p></div></div><div class="slide"><p class="em-above">3. hardware implementation</p><div class="notes">The final thing we need to understand the GPS locator is a description of the
hardware in which the algorithm is implemented.  It’s only here that 
we discover whether the device is narrowly mechanical device, using cogs, say, 
or an electronic device, or some new kind of biological entity.</div></div><div class="slide"><p class="indent">-- How are the  representations and algorithms physically realised?</p><div class="notes">The hardware implementation tells us how the representations and algorithms are represented physically.</div></div><p class="right grey-text">Marr (1992, 22ff)</p><div class="slide"><div data-what="p" data-css="{&quot;blur&quot;:&quot;2px&quot;}" data-options="{&quot;duration&quot;:500}" class="dv dv-velocity"></div><div class="notes">How is this relevant to the teleological stance?
It provides a computational description of goal ascription.
Whereas the Motor Theory provides an account of the representations and algorithms</div></div><div class="slide"><div data-what="p" data-css="{&quot;blur&quot;:0}" data-options="{&quot;duration&quot;:400}" class="dv dv-velocity"></div><div data-what=".computational" data-cls="bkg-grey-row " class="dv dv-addclass"></div><div class="notes">I suggest that an account of radical interpretation is suppsoed to provide
a computational description of social cognition; it tells us what social
cognition is for and how, in the most abstract sense, it is possible.</div></div></div></div></div></div></section></div></body></html>